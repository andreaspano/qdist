<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette}
-->
# Package `qdist`

##  Truncated probability function in `R`
 
`R` provides probability, density, quantile and random number generator functions using a stable naming convention both for the names of the functions and in the first argument of these functions:

* probability distribution functions `pdist(q)` with `q` vector of quantiles
* density functions `ddist(x)` with `x` vector of quantiles 
* quantile functions `qdist (p)` with `p` vector of probabilities. 
* random number generation `rdist (n)` with `n` number of observations

where `dist` indicates the type of distribution.

As a result we have: `pnorm(q)`, `dnorm(x)`, `qnorm(p)` and `rnorm(n)` for normal distribution and similarly for all other distributions

Therefore, we use to write:

```{r}
pnorm(q = 8:12, mean = 10, sd = 1)
````

to get probability values at `8:12` from a normal distribution with parameters `mean=10` and `sd=1`.

In case we need values from a truncated distribution, as far as we know, we need to load an extra package such as `truncdist`. 

```{r, echo = TRUE, message = FALSE}
require("truncdist")
```

The package itself works perfectly. In fact, assuming that  function `pnorm()` exists, we can get probability values from a normal distribution left truncated at `a` and right truncated at `b`, with parameters `mean = 10` and `sd = 1` by simply writing:

```{r}
ptrunc(q = 8:12 , spec = "norm", mean = 10 , sd = 1, a = 9, b = 11)
```

where `a = 9` and `b = 11` respectively represent the left and the right thresholds for truncation. 

Nevertheless, the above command requires a change in our programming style. We are used to have a single `R` function for each distribution: `pnorm()`, `pweibull()` etc ...

We could easily write function `tpnorm()`, a truncated version for `pnorm()`, as:

```{r, tidy=FALSE}
tpnorm <- 
  function (q, mean = 0, sd = 1, L = -Inf , U = Inf, ...){
    q <- pmax(pmin(q,U),L)  
    pq <- stats::pnorm(q = q, mean = mean, sd = sd, ...)
    pL <- stats::pnorm(q = L, mean = mean, sd = sd, ...)
    pU <- stats::pnorm(q = U, mean = mean, sd = sd, ...)
    p <- (pq-pL)/(pU-pL)
    p
}
```

This function clearly works:

```{r}
tpnorm( q = 8:12, mean = 10, sd = 1, L = 9, U = 11)
```
<!--- 
ptrunc(q =8:12, spec  = "norm", mean = 10, sd = 1, a = 9 , b = 11)
-->


but it is limited to the normal distribution. Following this approach, we would need to write a different function for each probability distribution and, we'll have to admit that all of this could become quite time consuming and not really efficient.

<!---
The same approach can also be applied to `dnorm()`, `qnorm()` and `rnorm()` or, more generaly, to any other distribution.
--->

As an alternative approach, we decided to develope package `qdist`: a package made of four functions: 

* `ptruncate()`: truncated probability distribution, 
* `dtruncate()`: truncated density function
* `qtruncate()`: truncated quantile functions
* `rtruncate()`: truncated random numbers generator functions. 

These functions share the same logic: they take as input a probability distribution as a character string and return the equivalent truncated distribution as a function object so that we can write:


```{r}
require(qdist)
tpnorm <- ptruncate("norm")
tdnorm <- dtruncate("norm")
tqnorm <- qtruncate("norm")
trnorm <- rtruncate("norm")
```


As a first detailed example, let's consider `ptruncate()` in more details applied to the normal case.

The newly generated function `tpnorm()` has the same formals as the original `pnorm()`, plus two extra parameters: `L` and `U`, respectively for lower and upper truncation thresholds set by default to `-Inf` and +`Inf`:.

```{r}
args(pnorm)
args(tpnorm)
```

Once we have defined `tpnorm()` we can use it for generating probabilities values from not-truncated normal distributions by leaving parameters `L` and `U` set to their defaults:  


```{r}
q <- seq(6, 14, len = 100) 
p_L_U <- tpnorm(q, mean = 10, sd = 1)

```


or from any truncated normal distribution by setting values for `L` and `U`:


```{r}
p_L9_U11 <- tpnorm(q, mean = 10, sd = 1, L = 9, U = 11)
```

We can visualize these results by plotting them as in \ref{fig:tnorm} 

```{r tnorm, tidy= FALSE, echo = FALSE , fig.height=4.5, fig.width=7, fig.pos="placehere", fig.lp = "fig:", fig.cap = ''}
plot(q, p_L_U, type = "n", xlab = "Quantile", ylab = "Probability")
lines(q, p_L_U, type = "l", col = "darkgray", lwd = 3)
lines(q, p_L9_U11, type = "l", col = "darkred", lwd = 3)
legend("topleft", legend = c("p_L_U", "p_L9_U11"), col = c("darkgray", "darkred"), lwd = 3, cex =1.25 , bty = "n" )
grid()
```


As a second example, we consider a density function for a left truncated Weibull distribution. We first generate function `tdweibull()` by using `dtruncate()`:

```{r}
tdweibull <- dtruncate("weibull")
```

and afterward, we can use it as:

```{r}
x <- qweibull(ppoints(1000), shape = 2, scale = 7)
d_L0 <- tdweibull(x, shape = 2, scale = 7)
d_L3 <- tdweibull(x, shape = 2, scale = 7, L = 3)
d_L5 <- tdweibull(x, shape = 2, scale = 7, L = 5)
d_L7 <- tdweibull(x, shape = 2, scale = 7, L = 7)
```

with the following results:

```{r, tidy= FALSE, echo = FALSE}
plot(x, d_L7, type = "n", xlab = "Quantile", ylab = "Density")
lines(x, d_L0, type = "l", col = "darkgray", lwd = 3)
lines(x, d_L3, type = "l", col = "darkred", lwd = 3)
lines(x, d_L5, type = "l", col = "darkblue", lwd = 3)
lines(x, d_L7, type = "l", col = "darkgreen", lwd = 3)
legend("topright", legend = c("d_L0", "d_L3", "d_L5", "d_L7"), col = c("darkgray", "darkred", "darkblue", "darkgreen"), lwd = 3, cex =1.25 , bty = "n" )
grid()
```

As an example of random number generator function we consider the Gumbel distribution from package `evd`:


```{r}
require(evd)
trgumbel <- rtruncate("gumbel")
args(trgumbel)
rg <- trgumbel(10^4, loc = 3, scale = 2, L = 5)
```
```{r, tidy= FALSE, echo = FALSE}
hist(rg, xlim = c(0,25), col = "gray", main = "Random data from truncated Gumbel distribution")
grid()
```

This approach works for both continuos and discrete probability functions. Let's consider the case of main quantiles generated from a Poisson distribution:

```{r}
tqpois <- qtruncate("pois")
tqpois(1:3/4, lambda = 100, L  = 90, U = 100)
```
<!---
as we can see, it returns identical results as function `qtrunc()` provided by package `truncdist`:

```{r}
require(truncdist)
qtrunc(1:3/4, spec = "pois", lambda = 100, a = 90, b = 100 )
```
--->

## The `gamma` case

The gamma case may result a bit foulty because of the check on input paramemters implemented within the body of the `gamma` set of functions.  As a consequence, suppose we define a truncated quantile the gamma distribution as:

```{r}
tqgamma <- qtruncate("gamma")
```

When we use `tqgamma()` with parameter `rate` it works but may return a set of `warnings`

```{r}
tqgamma(.25, shape = 1, rate = .3)
```

when we use the same function with parameter `scale`, it returns an error:

```{r}
try(tqgamma(ppoints(10), shape = 1, scale = 3))
```

Note that, if we simply redifine `qgamma()` and `pgamma()` as:

```{r}
qgamma <- function (p, shape, rate = 1, lower.tail = TRUE, log.p = FALSE) {
  scale <-  1/rate
  .External(stats:::C_qgamma, p, shape, scale, lower.tail, log.p)
}

pgamma <- function (q, shape, rate = 1, lower.tail = TRUE, log.p = FALSE) {
  scale <-  1/rate
  .External(stats:::C_pgamma, q, shape, scale, lower.tail, log.p)
}
```

now everyting should work fine:

```{r}
tqgamma <- qtruncate("gamma")
tqgamma(p = .25, shape = 1, rate = 3)
```

## Extending the computation
Once a truncated distribution is defined, we can use it as a building block for further implementations. 

Suppose we want to define a function for maximum likelihood estimate for the truncated normal distribution, we can achieve this by first defining the truncated density function for the normal distribution:

```{r}
tdnorm <- dtruncate("norm")
```

and, subsequently, by using `tdnorm()` within an estimator function:

```{r} 
ltnorm = function(x, L = -Inf, U = Inf) {
  theta <- c(mean(x), sd(x))
  ml <- function(theta , x, L = -Inf, U = Inf) {
        mean <- theta[1]
        sd <- theta[2]
        ml <-  tdnorm(x = x, mean = mean, sd = sd, L = L , U = U )
        -sum(log(ml))
      }
  optim(par = theta , fn = ml, x = x, L = L , U = U)$par
}
```

As a result:


```{r}
trnorm <- rtruncate("norm")
x <- trnorm(n = 1000, mean = 5, sd = 2, L = 3, U = 6)
ltnorm( x = x, L = 3, U = 6)
```


#```{r}
#require(knitr)
#knit2html("./vignettes/vignette.Rmd" ,output = "./vignettes/vignette.md")
#system("pandoc ./vignettes/vignette.md -o vignettes/vignette.pdf")
#```
