<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette.rmd}
-->

# Functions Factories

Package `qdist` is based on two functions key concepts:

* The environment of a function can be used as a placeholder for other objects
* Function formals can be manipulated


## Environment of a function

The _R Language Definition_ manual defines environments as: _''consisting of two things. A frame, consisting of a set of symbol-value pairs, and an enclosure, a pointer to an enclosing environment''_

This idea of a pointer to an enclosing environment is at the core of the `R` mechanism when looking for objects:

_''When R looks up the value for a symbol the frame is examined and if a matching symbol is found its value will be returned. If not, the enclosing environment is then accessed and the process repeated''_.

Environments in `R` play a crucial role as they just work in the background of any `R` functionality. 

Any `R` session has a an associated environment as returned by:

```{r}
environment()
```

and, very important for our purposes, any function has an associated environment as stated by the _R Language Definition_ manual: functions  _''have three basic components: a formal argument list, a body and an environment''_.

Specifically, the _environment of a function_ is the environment that was active at the time that the function was created. Generally, for user defined function, the Global environment:

```{r}
f <- function() 0
environment(f)
```

or, when a function is defined within a package, the environment associated to that package:

```{r}
environment(mean)
```

Along with the environment where the function was created, functions interact with several other environments. The _evaluation environment_ of a function is on of them.

The _evaluation environment_ of a function is created any time a function is called and is used to host the computation of the function.

The evaluation environment is destroyed when the function exits.

As any environment, the evaluation environment of a function has a parent: the environment of the function.

When we define a function, the function itself knows about its environment and, as a consequence, the function has access to all symbols belonging to that environment.

As an example we may consider a function defined in a dedicated environment along with some other objects defined in the same environment.


```{r}
env <- new.env()

with(env,{ 
     y <- 99
     g <- function(x){x+y}
     })


env$g(1)
```

As we can see, clearly `g()` knows that `x=1` as it was passed to the function as an argument but, `g()` also remembers that `y=99` as `y` belongs the the environment `env`: the environment of `g()`.

Playing with the environment of a function and the execution environment of a function, we can create a function `g()` that returns a function `f()`:

```{r}
g <- function() {
  f <- function() 0
  f
}
```

create `f()` as a result of a call to `g()`

```{r}
f <- g()
```

and normally run `f()` as:

```{r}
f()
```

in this case, the _evaluation environment_ of `g()` corresponds to the _environment_ of `f()` as `f()` is created within the _evaluation environment_ of `g()`. 

As a result, when `g()` exits, its _evaluation environment_ is not destroyed as it became the _environment_ of `f()`. 

Following this line, we can define `g(y)` so that the _evaluation environment_ of `g(y)` is used to pass any argument `y` to `f(x)`:

```{r}
g <- function(y) {
  f <- function(x) {x+y}
}
```

We can now define and run `f(x)` as:

```{r}
f <- g(1)
f(x = 2)
```

This mechanism allows us to define a _functions factory_: a function `g(y)` that, by varying the values assigned to `y`, allow many `fi(x)` to be defined with very little effort:

```{r}
f1 <- g(1)
f2 <- g(2)
f3 <- g(3)
```

and use them straighfortly:

```{r}
f1(x = 100)
f2(x = 100)
f3(x = 100)
```

## Formals argument list

The argument list of a function, as stated in _R Language Definition_ manual is: _''a comma-separated list of arguments. An argument can be a symbol, or a ‘symbol = default’ construct''_.

Function `formals()` returns the formal arguments of a function as an object of class `pairlist`. 

```{r}
formals_sd <- formals(sd)
formals_sd
class(formals_sd)
```

As a replacement method exists for function `formals`:

```{r functions-011}
exists("formals<-")
```

formals of a function can manipulated by using function `alist()`: a `list()` type function that handles unevaluated arguments

```{r}
f <- function(x, y=0) x+y
f(1)
formals(f) <- alist(x=, y=1)
f(1)
```

As an example of practical use of `formals()` we may decide to re-define function `mean()` that defaults `na.rm` to `TRUE` by simply:

```{r functions-013}
formals(mean.default)$na.rm <- TRUE
mean(c(1,2,NA))
```

## Package `qdist`

Package `qdist` can be thougth as a function factory for truncated distribution functions. Function `ptruncate()` takes as input the distribution name: say "norm" and procedes as follows:

* gets the corresponding function `pnorm()` 
* uses `pnorm()` to create a function, say `probability()` that computes truncated probability for normal ditributions
* modify the formals of `probability()` so that it has the same formals as `pnorm()` plus `L` and `U` corresponding to the lower and upper threshold for truncation
* Returns `probability()`
